import * as C from './constants';
import { Theme, EntityType } from './constants';
import { randomInt } from './utils';
import { Player } from './player';
import { Entity } from './interfaces'; // Use interface

// --- Bat Enemy (Unchanged) ---
export class Bat implements Entity { type = EntityType.BAT; x: number; y: number; width = C.BAT_WIDTH; height = C.BAT_HEIGHT; initialY: number; toBeRemoved = false; constructor() { this.x = C.GAME_WIDTH; this.initialY = randomInt(this.height * 2, C.GROUND_Y - this.height * 3); this.y = this.initialY; } update(gameSpeed: number, frameCount: number) { this.x -= gameSpeed * 1.1; this.y = this.initialY + Math.sin(frameCount * C.BAT_VERTICAL_FREQ) * C.BAT_VERTICAL_AMP; if (this.isOffScreen()) { this.toBeRemoved = true; } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { const wingFlap = Math.sin(frameCount * C.BAT_FLAP_SPEED) > 0; ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.shadowColor = theme.COLOR_ENEMY_BAT_GLOW; ctx.shadowBlur = 8; ctx.fillStyle = theme.COLOR_ENEMY_BAT_BODY; ctx.beginPath(); ctx.ellipse(0, 0, this.width / 2.5, this.height / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = theme.COLOR_ENEMY_BAT_WING; const wingHeight = this.height * (wingFlap ? 1.2 : 0.6); ctx.beginPath(); ctx.moveTo(-this.width * 0.1, 0); ctx.lineTo(-this.width * 0.5, -wingHeight / 2); ctx.lineTo(-this.width * 0.4, wingHeight / 2); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(this.width * 0.1, 0); ctx.lineTo(this.width * 0.5, -wingHeight / 2); ctx.lineTo(this.width * 0.4, wingHeight / 2); ctx.closePath(); ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.restore(); } isOffScreen(): boolean { return this.x + this.width < 0; } }

// --- Shooter Enemy (Unchanged - still static) ---
export class Shooter implements Entity { type = EntityType.SHOOTER; x: number; y: number; width = C.SHOOTER_SIZE; height = C.SHOOTER_SIZE; toBeRemoved = false; constructor(surfaceY: number) { this.x = C.GAME_WIDTH; this.y = surfaceY - this.height - C.SHOOTER_Y_OFFSET; } update(gameSpeed: number, frameCount: number, player?: Player, entities?: Entity[]) { this.x -= gameSpeed; if (this.isOffScreen()) { this.toBeRemoved = true; } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { ctx.save(); ctx.translate(this.x, this.y); ctx.shadowColor = theme.COLOR_ENEMY_SHOOTER_GLOW; ctx.shadowBlur = 12; ctx.fillStyle = theme.COLOR_ENEMY_SHOOTER_BODY; ctx.fillRect(0, 0, this.width, this.height); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; const eyeSize = this.width * 0.3 + Math.sin(frameCount * 0.1) * 2; ctx.fillStyle = theme.COLOR_ENEMY_SHOOTER_EYE; ctx.beginPath(); ctx.arc(this.width / 2, this.height / 2, eyeSize / 2, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 2; ctx.strokeRect(0, 0, this.width, this.height); ctx.restore(); } isOffScreen(): boolean { return this.x + this.width < 0; } }

// --- Lava Pit Hazard (Unchanged) ---
export class LavaPit implements Entity { type = EntityType.LAVA_PIT; x: number; y = C.GROUND_Y; width: number; height = C.GROUND_HEIGHT; toBeRemoved = false; bubbles: { x: number, y: number, size: number, life: number }[] = []; constructor(width: number) { this.x = C.GAME_WIDTH; this.width = width; } update(gameSpeed: number, frameCount: number) { this.x -= gameSpeed; if (this.isOffScreen()) { this.toBeRemoved = true; } if (Math.random() < C.LAVA_BUBBLE_RATE) { this.bubbles.push({ x: this.x + randomInt(5, this.width - 5), y: this.y + this.height - randomInt(5, 15), size: randomInt(3, 8), life: randomInt(15, 30) }); } this.bubbles = this.bubbles.filter(b => { b.life--; b.y -= 0.2; b.size *= 0.97; return b.life > 0 && b.size > 0.5; }); } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { const lavaY = this.y + C.GROUND_LINE_THICKNESS; const lavaHeight = this.height - C.GROUND_LINE_THICKNESS; const grad = ctx.createLinearGradient(this.x, lavaY, this.x, lavaY + lavaHeight); grad.addColorStop(0, theme.COLOR_ENV_LAVA1); grad.addColorStop(1, theme.COLOR_ENV_LAVA2); ctx.fillStyle = grad; ctx.fillRect(this.x, lavaY, this.width, lavaHeight); this.bubbles.forEach(b => { const alpha = b.life / 30; ctx.fillStyle = `${theme.COLOR_ENV_LAVA_GLOW}${Math.floor(alpha * 150).toString(16).padStart(2, '0')}`; ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2); ctx.fill(); }); } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Rain Cloud Environment (Unchanged) ---
export class RainCloud implements Entity { type = EntityType.RAIN_CLOUD; x: number; y: number; width = C.RAIN_CLOUD_WIDTH; height = C.RAIN_CLOUD_HEIGHT; speedFactor = C.RAIN_CLOUD_SPEED_FACTOR; toBeRemoved = false; rainDrops: { x: number, y: number, life: number }[] = []; constructor() { this.x = C.GAME_WIDTH + randomInt(50, 200); this.y = randomInt(this.height, C.GAME_HEIGHT * 0.3); } update(gameSpeed: number, frameCount: number) { this.x -= gameSpeed * this.speedFactor; if (this.isOffScreen()) { this.toBeRemoved = true; } if (Math.random() < C.RAIN_RATE) { this.rainDrops.push({ x: this.x + randomInt(5, this.width - 5), y: this.y + this.height - 5, life: 50 }); } this.rainDrops = this.rainDrops.filter(r => { r.life--; r.y += C.RAIN_SPEED; return r.life > 0 && r.y < C.GROUND_Y; }); } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { ctx.fillStyle = theme.COLOR_ENV_CLOUD; const baseSize = this.width * 0.3; const wobble = Math.sin(frameCount * 0.05) * 3; ctx.beginPath(); ctx.ellipse(this.x + this.width * 0.3, this.y + this.height * 0.5 + wobble, baseSize, baseSize * 0.8, 0, 0, Math.PI * 2); ctx.ellipse(this.x + this.width * 0.7, this.y + this.height * 0.5 - wobble, baseSize * 1.1, baseSize * 0.9, 0, 0, Math.PI * 2); ctx.ellipse(this.x + this.width * 0.5, this.y + this.height * 0.4 + wobble, baseSize * 0.9, baseSize * 0.7, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = theme.COLOR_ENV_RAIN; ctx.lineWidth = 1.5; this.rainDrops.forEach(r => { ctx.beginPath(); ctx.moveTo(r.x, r.y); ctx.lineTo(r.x, r.y + C.RAIN_LENGTH); ctx.stroke(); }); } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Cow Obstacle (Unchanged) ---
export class Cow implements Entity { type = EntityType.COW; x: number; y: number; width = C.COW_WIDTH; height = C.COW_HEIGHT; toBeRemoved = false; legPhase: number = 0; constructor() { this.x = C.GAME_WIDTH; this.y = C.GROUND_Y - this.height; } update(gameSpeed: number, frameCount: number) { this.x -= gameSpeed * C.COW_MOVE_SPEED_FACTOR; if (this.isOffScreen()) { this.toBeRemoved = true; } this.legPhase = Math.sin(frameCount * 0.15); } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { ctx.save(); ctx.translate(this.x, this.y); ctx.shadowColor = theme.COLOR_ENEMY_COW_GLOW; ctx.shadowBlur = 8; const legW = this.width * 0.15; const legH = this.height * 0.4; ctx.fillStyle = theme.COLOR_ENEMY_COW_BODY; ctx.fillRect(this.width * 0.1, this.height - legH, legW, legH + this.legPhase * 3); ctx.fillRect(this.width * 0.3, this.height - legH, legW, legH - this.legPhase * 3); ctx.fillRect(this.width * 0.6, this.height - legH, legW, legH + this.legPhase * 3); ctx.fillRect(this.width * 0.8, this.height - legH, legW, legH - this.legPhase * 3); ctx.beginPath(); ctx.roundRect(0, 0, this.width, this.height * 0.7, 10); ctx.fillStyle = theme.COLOR_ENEMY_COW_BODY; ctx.fill(); ctx.fillStyle = theme.COLOR_ENEMY_COW_SPOTS; ctx.beginPath(); ctx.ellipse(this.width * 0.3, this.height * 0.3, 8, 5, Math.PI / 4, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.ellipse(this.width * 0.7, this.height * 0.4, 10, 7, -Math.PI / 6, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = theme.COLOR_ENEMY_COW_BODY; ctx.beginPath(); ctx.arc(this.width * 0.85, this.height * 0.3, this.height * 0.2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(this.width * 0.9, this.height * 0.28, 3, 0, Math.PI * 2); ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.restore(); } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Triple Spike Obstacle (Unchanged) ---
export class TripleSpike implements Entity { type = EntityType.TRIPLE_SPIKE; x: number; y: number; width: number; height = C.SPIKE_HEIGHT; toBeRemoved = false; spikeWidth = C.SPIKE_BASE_WIDTH; spacing = C.TRIPLE_SPIKE_SPACING; constructor() { this.x = C.GAME_WIDTH; this.y = C.GROUND_Y - this.height; this.width = this.spikeWidth * 3 + this.spacing * 2; } update(gameSpeed: number) { this.x -= gameSpeed; if (this.isOffScreen()) { this.toBeRemoved = true; } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { ctx.shadowColor = theme.COLOR_OBSTACLE_GLOW; ctx.shadowBlur = 10; ctx.fillStyle = theme.COLOR_OBSTACLE_SPIKE; for (let i = 0; i < 3; i++) { const spikeX = this.x + i * (this.spikeWidth + this.spacing); ctx.beginPath(); ctx.moveTo(spikeX, this.y + this.height); ctx.lineTo(spikeX + this.spikeWidth / 2, this.y); ctx.lineTo(spikeX + this.spikeWidth, this.y + this.height); ctx.closePath(); ctx.fill(); } ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Block Stack Obstacle (Unchanged) ---
export class BlockStack implements Entity { type = EntityType.BLOCK_STACK; x: number; y: number; width: number; height: number; toBeRemoved = false; blockCount: number; blockHeight: number; constructor() { this.x = C.GAME_WIDTH; this.blockCount = randomInt(C.BLOCK_STACK_COUNT_MIN, C.BLOCK_STACK_COUNT_MAX); this.width = randomInt(C.BLOCK_SIZE_MIN, C.BLOCK_SIZE_MAX); this.blockHeight = this.width; this.height = this.blockHeight * this.blockCount; this.y = C.GROUND_Y - this.height; } update(gameSpeed: number) { this.x -= gameSpeed; if (this.isOffScreen()) { this.toBeRemoved = true; } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { ctx.shadowColor = theme.COLOR_OBSTACLE_GLOW; ctx.shadowBlur = 10; ctx.fillStyle = theme.COLOR_OBSTACLE_BLOCK; ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 2; for (let i = 0; i < this.blockCount; i++) { const blockY = this.y + i * this.blockHeight; ctx.fillRect(this.x, blockY, this.width, this.blockHeight); ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(this.x + 3, blockY + 3, this.width - 6, this.blockHeight - 6); ctx.strokeRect(this.x, blockY, this.width, this.blockHeight); ctx.fillStyle = theme.COLOR_OBSTACLE_BLOCK; } ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Floating Gear Obstacle (Unchanged) ---
export class FloatingGear implements Entity { type = EntityType.FLOATING_GEAR; x: number; y: number; width: number; height: number; radius: number; rotation: number = 0; numTeeth: number = 12; toBeRemoved = false; constructor() { this.radius = C.GEAR_RADIUS; this.width = this.radius * 2; this.height = this.radius * 2; this.x = C.GAME_WIDTH; this.y = randomInt(this.height * 2, C.GROUND_Y - this.height * 3 - C.PLAYER_SIZE); } update(gameSpeed: number) { this.x -= gameSpeed; this.rotation += C.GEAR_ROTATION_SPEED; if(this.isOffScreen()) this.toBeRemoved = true; } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { const centerX = this.x + this.radius; const centerY = this.y + this.radius; ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(this.rotation); ctx.shadowColor = theme.COLOR_OBSTACLE_GLOW; ctx.shadowBlur = 15; ctx.fillStyle = theme.COLOR_OBSTACLE_GEAR_OUTER; ctx.beginPath(); for (let i = 0; i < this.numTeeth; i++) { const angle = (i / this.numTeeth) * Math.PI * 2; const nextAngle = ((i + 0.5) / this.numTeeth) * Math.PI * 2; const outerX = Math.cos(angle) * this.radius; const outerY = Math.sin(angle) * this.radius; const innerX = Math.cos(nextAngle) * this.radius * 0.75; const innerY = Math.sin(nextAngle) * this.radius * 0.75; if (i === 0) { ctx.moveTo(outerX, outerY); } else { ctx.lineTo(outerX, outerY); } ctx.lineTo(innerX, innerY); } ctx.closePath(); ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.fillStyle = theme.COLOR_OBSTACLE_GEAR_INNER; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = theme.COLOR_OBSTACLE_GEAR_OUTER; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Moving Platform Obstacle (Unchanged) ---
export class MovingPlatform implements Entity { type = EntityType.MOVING_PLATFORM; x: number; y: number; initialY: number; width: number; height = C.PLATFORM_HEIGHT; toBeRemoved = false; amplitude = C.MOVING_PLATFORM_AMP; frequency = C.MOVING_PLATFORM_FREQ; constructor() { this.width = randomInt(C.PLATFORM_MIN_WIDTH, C.PLATFORM_MAX_WIDTH); this.x = C.GAME_WIDTH; const yOffset = randomInt(C.PLATFORM_MIN_Y_OFFSET + this.amplitude / 2, C.PLATFORM_MAX_Y_OFFSET - this.amplitude / 2); this.initialY = C.GROUND_Y - yOffset - this.height; this.y = this.initialY; } update(gameSpeed: number, frameCount: number) { this.x -= gameSpeed; this.y = this.initialY + Math.sin(frameCount * this.frequency) * this.amplitude / 2; if (this.isOffScreen()) { this.toBeRemoved = true; } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { ctx.shadowColor = theme.COLOR_OBSTACLE_GLOW; ctx.shadowBlur = 10; ctx.fillStyle = theme.COLOR_OBSTACLE_PLATFORM; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(this.x + 3, this.y + 3, this.width - 6, this.height - 6); ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height); ctx.fillStyle = theme.COLOR_GROUND_TOP; ctx.fillRect(this.x, this.y, this.width, C.GROUND_LINE_THICKNESS); } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Saw Blade Obstacle (Unchanged) ---
export class SawBlade implements Entity { type = EntityType.SAW_BLADE; x: number; y: number; width: number; height: number; radius: number; rotation: number = 0; toBeRemoved = false; numTeeth: number = 10; constructor() { this.radius = C.SAW_BLADE_RADIUS; this.width = this.radius * 2; this.height = this.radius * 2; this.x = C.GAME_WIDTH; const onGround = Math.random() < 0.6; this.y = onGround ? C.GROUND_Y - this.height : randomInt(this.height, C.GROUND_Y - this.height * 2); } update(gameSpeed: number, frameCount: number) { this.x -= gameSpeed; this.rotation -= C.SAW_BLADE_ROTATION_SPEED; if (this.isOffScreen()) { this.toBeRemoved = true; } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { const centerX = this.x + this.radius; const centerY = this.y + this.radius; ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(this.rotation); ctx.shadowColor = theme.COLOR_OBSTACLE_SAWBLADE_GLOW; ctx.shadowBlur = 15; ctx.fillStyle = theme.COLOR_OBSTACLE_SAWBLADE; ctx.beginPath(); for (let i = 0; i < this.numTeeth; i++) { const angle0 = (i / this.numTeeth) * Math.PI * 2 - Math.PI / this.numTeeth * 0.5; const angle1 = (i / this.numTeeth) * Math.PI * 2; const angle2 = (i / this.numTeeth) * Math.PI * 2 + Math.PI / this.numTeeth * 0.5; const innerRadius = this.radius * 0.7; ctx.moveTo(Math.cos(angle0) * innerRadius, Math.sin(angle0) * innerRadius); ctx.lineTo(Math.cos(angle1) * this.radius, Math.sin(angle1) * this.radius); ctx.lineTo(Math.cos(angle2) * innerRadius, Math.sin(angle2) * innerRadius); } ctx.closePath(); ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.fillStyle = theme.COLOR_OBSTACLE_SAWBLADE_INNER; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = theme.COLOR_OBSTACLE_SAWBLADE; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Crusher Obstacle (Unchanged) ---
export enum CrusherState { IDLE, WARNING, CRUSHING, RETRACTING } // Export if needed elsewhere
export class Crusher implements Entity { type = EntityType.CRUSHER; x: number; y: number; initialY: number = -C.CRUSHER_HEIGHT; targetY: number = C.GROUND_Y - C.CRUSHER_HEIGHT; width = C.CRUSHER_WIDTH; height = C.CRUSHER_HEIGHT; toBeRemoved = false; state: CrusherState = CrusherState.IDLE; stateTimer: number = 0; constructor() { this.x = C.GAME_WIDTH; this.y = this.initialY; } update(gameSpeed: number, frameCount: number, player?: Player) { this.x -= gameSpeed; if (this.isOffScreen()) { this.toBeRemoved = true; } switch (this.state) { case CrusherState.IDLE: if (player && player.x + player.width > this.x - C.CRUSHER_TRIGGER_DIST && player.x < this.x + this.width + C.CRUSHER_TRIGGER_DIST && player.y + player.height > this.y ) { this.state = CrusherState.WARNING; this.stateTimer = 15; } break; case CrusherState.WARNING: this.stateTimer--; if (this.stateTimer <= 0) { this.state = CrusherState.CRUSHING; } break; case CrusherState.CRUSHING: this.y += C.CRUSHER_SPEED; if (this.y >= this.targetY) { this.y = this.targetY; this.state = CrusherState.RETRACTING; this.stateTimer = C.CRUSHER_WAIT_TIME; } break; case CrusherState.RETRACTING: this.stateTimer--; if (this.stateTimer <= 0) { this.y -= C.CRUSHER_SPEED / 2; if (this.y <= this.initialY) { this.y = this.initialY; this.state = CrusherState.IDLE; } } break; } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { ctx.save(); ctx.translate(this.x, this.y); ctx.shadowColor = theme.COLOR_OBSTACLE_CRUSHER_GLOW; ctx.shadowBlur = 15; ctx.fillStyle = theme.COLOR_OBSTACLE_CRUSHER_BODY; ctx.fillRect(0, 0, this.width, this.height); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.strokeStyle = theme.COLOR_OBSTACLE_CRUSHER_DETAIL; ctx.lineWidth = 3; for (let i = 1; i < 4; i++) { const yPos = (this.height / 4) * i; ctx.beginPath(); ctx.moveTo(0, yPos); ctx.lineTo(this.width, yPos); ctx.stroke(); } ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 2; ctx.strokeRect(0, 0, this.width, this.height); if (this.state === CrusherState.WARNING && frameCount % 4 < 2) { ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.fillRect(0, 0, this.width, this.height); } ctx.restore(); } isOffScreen(): boolean { return this.x + this.width < 0; } }
// --- Laser Beam Obstacle (Unchanged) ---
export enum LaserState { CHARGING, ACTIVE, COOLDOWN } // Export if needed elsewhere
export class LaserBeam implements Entity { type = EntityType.LASER_BEAM; x: number; y: number; width = C.GAME_WIDTH + 100; height = C.LASER_BEAM_THICKNESS; toBeRemoved = false; state: LaserState = LaserState.COOLDOWN; stateTimer: number = C.LASER_COOLDOWN_TIME; emitterX = -50; constructor() { this.x = this.emitterX; this.y = randomInt(C.PLAYER_SIZE * 2, C.GROUND_Y - C.PLAYER_SIZE * 2); } update(gameSpeed: number, frameCount: number) { this.stateTimer--; if (this.stateTimer <= 0) { switch (this.state) { case LaserState.COOLDOWN: this.state = LaserState.CHARGING; this.stateTimer = C.LASER_CHARGE_TIME; break; case LaserState.CHARGING: this.state = LaserState.ACTIVE; this.stateTimer = C.LASER_ACTIVE_TIME; break; case LaserState.ACTIVE: this.state = LaserState.COOLDOWN; this.stateTimer = C.LASER_COOLDOWN_TIME; break; } } } draw(ctx: CanvasRenderingContext2D, frameCount: number, theme: Theme) { const beamY = this.y + this.height / 2; ctx.fillStyle = theme.COLOR_OBSTACLE_BLOCK; ctx.fillRect(this.emitterX, this.y - 5, 40, this.height + 10); if (this.state === LaserState.CHARGING) { const alpha = 0.5 + Math.sin(frameCount * 0.2) * 0.3; ctx.strokeStyle = `${theme.COLOR_OBSTACLE_LASER_WARNING}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.emitterX + 40, beamY); ctx.lineTo(C.GAME_WIDTH, beamY); ctx.stroke(); } else if (this.state === LaserState.ACTIVE) { ctx.shadowColor = theme.COLOR_OBSTACLE_LASER_GLOW; ctx.shadowBlur = 10; ctx.fillStyle = theme.COLOR_OBSTACLE_LASER_BEAM; ctx.fillRect(this.emitterX + 40, this.y, this.width - 40, this.height); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.fillRect(this.emitterX + 40, this.y + this.height * 0.3, this.width - 40, this.height * 0.4); } } isOffScreen(): boolean { return false; } } // Laser never goes off-screen
